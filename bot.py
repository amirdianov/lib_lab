"""
Telegram bot LibLab
"""
import time

from telegram import ShippingOption, LabeledPrice, InlineKeyboardButton, InlineKeyboardMarkup, ReplyKeyboardRemove
from telegram.ext import PreCheckoutQueryHandler, CallbackQueryHandler

from registration import *
from subscription import *
from take_book import *
from db_func import *

logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s', level=logging.INFO
)

logger = logging.getLogger(__name__)

TOKEN: str = '5153990837:AAHVrwUUYPFwfQlGv37TeZ2A3dsW1MYWRis'


def start_messaging(update: Update, context: Any) -> int:
    """Function greets the user"""
    update.message.reply_text('–í–∞—Å –ø—Ä–∏–≤–µ—Ç—Å—Ç–≤—É–µ—Ç —Ç–µ–ª–µ–≥—Ä–∞–º-–±–æ—Ç \n'
                              '—ç–ª–µ–∫—Ç—Ä–æ–Ω–Ω–æ–π –±–∏–±–ª–∏–æ—Ç–µ–∫–∏ LibLabüëã\n'
                              '–í –Ω–∞—à–µ–π –±–∏–±–ª–∏–æ—Ç–µ–∫–µ –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–∞ –≤–Ω—É—à–∏—Ç–µ–ª—å–Ω–∞—è –∫–æ–ª–ª–µ–∫—Ü–∏—è –∫–Ω–∏–≥ –Ω–∞ –ª—é–±–æ–π –≤–∫—É—Å üëç\n'
                              '–ñ–µ–ª–∞—é –≤–∞–º –ø—Ä–∏—è—Ç–Ω–æ–≥–æ —á—Ç–µ–Ω–∏—è ü§ì')
    methods_func(update, context)
    us_id = update.message.from_user.id
    User.User_id = us_id
    add_item(us_id)


def help_func(update: Update, context: Any) -> None:
    """Function gives some important information"""
    update.message.reply_text('–í–∞–º –Ω—É–∂–Ω–∞ –ø–æ–º–æ–º—â—å‚ùì \n–î–∞–≤–∞–π—Ç–µ —è –≤–∞–º —Ä–∞—Å—Å–∫–∞–∂—É –æ —Ç–æ–º, —á—Ç–æ —è —É–º–µ—é: \n'
                              'üìñtake_book - —ç—Ç–æ—Ç –º–µ—Ç–æ–¥ –ø–æ–∑–≤–æ–ª—è–µ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é –ø–æ–ª—É—á–∏—Ç—å –∫–Ω–∏–≥—É\n'
                              'üìÖsubscription - —ç—Ç–æ—Ç –º–µ—Ç–æ–¥ –ø–æ–º–æ–≥–∞–µ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é –æ—Ñ–æ—Ä–º–∏—Ç—å –ø–æ–¥–ø–∏—Å–∫—É\n'
                              'üíªregistration - —ç—Ç–æ—Ç –º–µ—Ç–æ–¥ –ø–æ–º–æ–≥–∞–µ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é –∑–∞—Ä–µ–≥–µ—Å—Ç—Ä–∏—Ä–æ–≤–∞—Ç—å—Å—è –≤ –Ω–∞—à–µ–π –±–∏–±–ª–∏–æ—Ç–µ–∫–µ\n'
                              '–ö—É–¥–∞ –æ—Ç–ø—Ä–∞–≤–∏–º—Å—è‚ùì')
    time.sleep(2)
    methods_func(update, context)


def methods_func(update: Update, context: Any) -> None:
    """Function gets methods"""
    methods_reply_keyboard = [['üìñtake_book', 'üìÖsubscription'], ['‚ùìhelp', 'üíªregistration']]
    methods_markup = ReplyKeyboardMarkup(methods_reply_keyboard, one_time_keyboard=True, resize_keyboard=True)
    update.message.reply_text('–í–æ—Ç –¥–µ–π—Å—Ç–≤—É—é—â–∏–µ –º–µ—Ç–æ–¥—ã:', reply_markup=methods_markup)


class User:
    CRITERION: dict = {
        'title': '–Ω–∞–∑–≤–∞–Ω–∏–µ',
        'genre': '–∂–∞–Ω—Ä',
        'author': '–∞–≤—Ç–æ—Ä–∞',
    }
    User_id = None

    def __init__(self, id, name_surname, registration, subscription):
        self.id = id
        self.name_surname = name_surname
        self.registration = registration
        self.subscription = subscription

    def begin_registration_user_func(self: Update, context: Any):
        # us_id = self.message.from_user.id
        # User.User_id = us_id
        flag: bool = begin_registration_user(self, context)
        if flag:
            return 1
        time.sleep(2)
        methods_func(self, context)
        return ConversationHandler.END

    def registration_handle_user_data_func(self: Update, context: Any):
        flag: bool = registration_handle_user_data(self, context)
        if flag:
            time.sleep(2)
            methods_func(self, context)
            return ConversationHandler.END
        return 1

    def begin_subscription_user_func(self: Update, context: Any):
        # us_id = self.message.from_user.id
        # User.User_id = us_id
        flag: bool = subscription_user(self, context)
        if not flag:
            time.sleep(2)
            methods_func(self, context)
            return ConversationHandler.END
        else:
            active = subscription_activated_check(self, context)
            if active:
                subscription_not_need_active(self, context)
                return 1
            else:
                subscription_need_active(self, context)
                return 2

    def subscription_need_ans_func(self: Update, context: Any):
        if subscription_need_ans(self, context):
            return ConversationHandler.END
        else:
            time.sleep(2)
            methods_func(self, context)
        return ConversationHandler.END

    def subscription_not_need_active_func(self: Update, context: Any):
        if subscription_not_need_active_ans(self, context):
            return ConversationHandler.END
        else:
            time.sleep(2)
            methods_func(self, context)
        return ConversationHandler.END

    def begin_take_book_user_func(self: Update, context: Any):
        # us_id = self.message.from_user.id
        # User.User_id = us_id
        if take_book_user(self, context):
            take_book_type(self, context)
            return 1
        else:
            time.sleep(2)
            methods_func(self, context)

    def take_book_1_func(self: Update, context: Any):
        print('–°—Ç–∞–¥–∏—è take_book_1_func')
        ans = self.message.text
        # –∑–¥–µ—Å—å –Ω–∞–¥–æ –Ω–µ –∑–∞–≤–µ—Ä—à–∞—Ç—å ConversationHandler, –∞ –ø—Ä–æ–¥–æ–ª–∂–∏—Ç—å
        # —á—Ç–æ–±—ã –¥–∞–ª—å—à–µ –ø–∏—Å–∞—Ç—å —Å–≤–æ–π –±–ª–æ–∫ –≤–∑—è—Ç–∏—è –∫–Ω–∏–≥–∏ –ø–æ —Ç–∏–ø—É
        if ans == 'title' or ans == 'genre':
            flag = User.find_book_function(self, context)
            return flag
        else:
            # –ú–æ–∂–Ω–æ –∫–∞–∫ —Ç–æ —Ç–∞–∫ –ø—Ä–æ–¥–æ–ª–∂–∏—Ç—å
            self.message.reply_text('–ß—Ç–æ - —Ç–æ –ø–æ—à–ª–æ –Ω–µ —Ç–∞–∫ –∏ –±–æ—Ç —Å–ª–æ–º–∞–ª—Å—è...')

    def find_book_function(self: Update, context: Any):
        inner_find_book_function(self, context, User.CRITERION[self.message.text])
        return User.CRITERION[self.message.text]

    def take_book_title(self: Update, context: Any):
        print('–°—Ç–∞–¥–∏—è take_book_title')
        print('Message text:', self.message.text)
        inner_take_book(self, context, self.message.text.capitalize(), 'title')
        delete_second_telegram_message(context.user_data['message'])
        return 'checking_stage'

    def take_book_genre(self: Update, context: Any):
        print('–°—Ç–∞–¥–∏—è take_genre')

    def take_book_genre_1(self: Update, context: Any, name_genre: Any):
        create_buttons_book(self, context, name_genre, User.User_id)
        delete_second_telegram_message(context.user_data['message'])
        return 'checking_stage'

    def take_book_author(self: Update, context: Any):
        ...
        return ConversationHandler.END

    def take_book_rating(self: Update, context: Any):
        ...
        return ConversationHandler.END

    def find_book_function_for_inline(self, context: Any):
        print('–°—Ç–∞–¥–∏—è find_book_function_for_inline')
        print('context.user_data', context.user_data['criterion'])
        response = self.callback_query
        inner_find_book_function_for_inline(response, context)
        response.answer()
        delete_telegram_message(response)
        return context.user_data['criterion']

    def check_book(self: Update, context: Any):
        print('–°—Ç–∞–¥–∏—è check_book')
        return User.inner_check_book(self, context)

    def handle_subscription_case(self: Update, context: Any):
        print('–°—Ç–∞–¥–∏—è handle_subscription_case')
        ReplyKeyboardRemove()
        inner_handle_subscription_case(self, context)
        return ConversationHandler.END

    def inner_check_book(self, context: Any):
        print("callback_query:", self.callback_query.data)
        response = self.callback_query
        response.answer()
        if response.data == 'need_to_get_subscription':
            reply_buttons = [['üòç–î–∞', '–ù–µ—Ç...']]
            reply_button_markup = ReplyKeyboardMarkup(reply_buttons, one_time_keyboard=True, resize_keyboard=True)
            response.message.reply_text('–ö —Å–æ–∂–∞–ª–µ–Ω–∏—é, —ç—Ç–∞ –∫–Ω–∏–≥–∞ –¥–æ—Å—Ç—É–ø–Ω–∞ —Ç–æ–ª—å–∫–æ –ø–æ –ø–æ–¥–ø–∏—Å–∫–µüòî\n'
                                        '–ñ–µ–ª–∞–µ—Ç–µ –ª–∏ –≤—ã –µ—ë –æ—Ñ–æ—Ä–º–∏—Ç—å?', reply_markup=reply_button_markup)
            return 'subscribe_stage'
        elif response.data == 'back_to_prev_state':
            delete_telegram_message(response)
            return User.find_book_function_for_inline(self, context)
        elif response.data == 'back_to_prev_state_1':
            delete_telegram_message(response)
            return User.find_book_function_for_inline(self, context)
        elif response.data == 'back_to_main_menu':
            delete_telegram_message(response)
            delete_second_telegram_message(context.user_data['message'])
            methods_func(response, context)
            return ConversationHandler.END

    def handle_coming_back(self, context):
        print('–°—Ç–∞–¥–∏—è handle_coming_back_new')
        print(self.callback_query.data)
        response = self.callback_query
        print('id:', self.callback_query.message.chat.id)
        if response.data == 'back_to_main_menu':
            response.answer()
            delete_second_telegram_message(context.user_data['message'])
            delete_telegram_message(response)
            methods_func(response, context)
            return ConversationHandler.END
        elif response.data == 'back_to_prev_state':
            response.answer()
            delete_telegram_message(response)
            return User.begin_take_book_user_func(response, context)
        elif response.data == 'back_to_prev_state_1':
            response.answer()
            delete_telegram_message(response)
            return User.take_book_genre(response, context)
        else:
            return User.take_book_genre_1(response, context, response.data)


class Subscription:
    def __init__(self, id, exists_since, valid_until, activity):
        self.id = id
        self.exists_since = exists_since
        self.valid_until = valid_until
        self.activity = activity

    def renew_dates_func(self: Update, context: CallbackContext):
        pass

    # checking correction pay
    def precheckout_callback(self: Update, context: Any) -> None:
        query = self.pre_checkout_query
        if query.invoice_payload != 'Custom-Payload':
            # answer False pre_checkout_query
            query.answer(ok=False, error_message="–£–ø—Å...–ö–∞–∫–∞—è-—Ç–æ –æ—à–∏–±–∫–∞.")
        else:
            query.answer(ok=True)

    # message after pay
    def successful_payment_callback(self: Update, context: Any) -> None:
        """Confirms the successful payment."""
        # do something after successfully receiving payment?
        self.message.reply_text("–ß–∏—Ç–∞–π—Ç–µ —Å —É–¥–æ–≤–æ–ª—å—Å—Ç–≤–∏–µ–º!üìö")
        time.sleep(2)
        user_id = self.message.from_user.id
        if get_items('exists_since', 'Subscription', 'telegram_id',
                     user_id)[0] is not None:
            renew_dates_user(self, context, user_id)
        else:
            new_dates_user(self, context, user_id)
        methods_func(self, context)


class Book:
    def __init__(self, id, author, genre, availability):
        self.id = id
        self.author = author
        self.genre = genre
        self.availability = availability


def command(update: Update, context: Any):
    command = update.message.text
    update.message.reply_text('–£–≤—ã‚òπ, –Ω–æ —è —Ç–µ–±—è –Ω–µ –ø–æ–Ω–∏–º–∞—é.\n–ü–æ–ø—Ä–æ–±—É–π –≤–æ—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å—Å—è —ç—Ç–∏–º–∏ –∫–æ–º–∞–Ω–¥–∞–º–∏üëá')
    time.sleep(1)
    help_func(update, context)


def stop(update: Update, context: Any):
    update.message.reply_text(
        "–ü–æ–∫–∞-–ø–æ–∫–∞")


def main() -> None:
    """main function organizes work of our bot"""
    updater: Updater = Updater(TOKEN, use_context=True)
    dispatcher = updater.dispatcher
    dispatcher.add_handler(CommandHandler('start', start_messaging))
    dispatcher.add_handler(CommandHandler('methods', start_messaging))

    # dispatcher.add_handler(PrefixHandler('üìÉ', 'methods', methods_func))
    dispatcher.add_handler(PrefixHandler('‚ùì', 'help', help_func))
    conv_handler = ConversationHandler(
        entry_points=[PrefixHandler('üìñ', 'take_book', User.begin_take_book_user_func),
                      CallbackQueryHandler(User.find_book_function_for_inline, pass_user_data=True)],
        states={
            1: [MessageHandler(Filters.text, User.take_book_1_func, pass_user_data=True)],
            '–Ω–∞–∑–≤–∞–Ω–∏–µ': [MessageHandler(Filters.text, User.take_book_title, pass_user_data=True),
                         CallbackQueryHandler(User.handle_coming_back, pass_user_data=True)],
            '–∂–∞–Ω—Ä': [MessageHandler(Filters.text, User.take_book_genre, pass_user_data=True),
                     CallbackQueryHandler(User.handle_coming_back, pass_user_data=True)],
            '–∞–≤—Ç–æ—Ä–∞': [MessageHandler(Filters.text, User.take_book_author, pass_user_data=True)],
            'rating': [MessageHandler(Filters.text, User.take_book_rating, pass_user_data=True)],
            'checking_stage': [CallbackQueryHandler(User.check_book, pass_user_data=True)],
            'subscribe_stage': [MessageHandler(Filters.text, User.handle_subscription_case, pass_user_data=True)]
        }, fallbacks=[CommandHandler('stop', stop)]
    )
    dispatcher.add_handler(conv_handler)
    conv_handler_registration = ConversationHandler(
        entry_points=[PrefixHandler('üíª', 'registration', User.begin_registration_user_func)],
        states={
            1: [MessageHandler(Filters.text, User.registration_handle_user_data_func, pass_user_data=True)]
        }, fallbacks=[CommandHandler('stop', stop)])
    dispatcher.add_handler(conv_handler_registration)

    conv_handler_subscription = ConversationHandler(
        entry_points=[PrefixHandler('üìÖ', 'subscription', User.begin_subscription_user_func)],
        states={
            1: [MessageHandler(Filters.text, User.subscription_not_need_active_func, pass_user_data=True)],
            2: [MessageHandler(Filters.text, User.subscription_need_ans_func, pass_user_data=True)]
        }, fallbacks=[CommandHandler('stop', stop)])
    dispatcher.add_handler(conv_handler_subscription)

    # don't touch!
    dispatcher.add_handler(PreCheckoutQueryHandler(Subscription.precheckout_callback))
    dispatcher.add_handler(MessageHandler(Filters.successful_payment, Subscription.successful_payment_callback))
    dispatcher.add_handler(MessageHandler(Filters.text, command, pass_user_data=True))
    updater.start_polling()

    updater.idle()


if __name__ == '__main__':
    main()
